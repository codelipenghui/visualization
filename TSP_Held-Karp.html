<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP - Held-Karp Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
            font-size: 0.875rem;
        }
        .container-card {
            background-color: #ffffff;
            border: 1px solid #e2e8f0; /* slate-200 */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.07), 0 2px 4px -2px rgb(0 0 0 / 0.07);
        }
        .section-title {
            color: #334155; /* slate-700 */
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
            font-size: 1.125rem;
            font-weight: 600;
        }
        .label-text {
            color: #475569; /* slate-600 */
            font-size: 0.8rem;
        }
        .input-field {
            background-color: #f8fafc;
            color: #1e293b;
            border: 1px solid #cbd5e1; /* slate-300 */
            padding: 0.625rem;
            font-size: 0.8rem;
            border-radius: 0.375rem;
        }
        .input-field:focus {
            border-color: #64748b; /* slate-500 */
            box-shadow: 0 0 0 2px rgba(100, 116, 139, 0.2);
            outline: none;
        }
        .btn {
            padding: 0.5rem 1rem; 
            border: 1px solid #cbd5e1; 
            transition: background-color 0.2s, color 0.2s;
            font-size: 0.75rem; 
            border-radius: 0.375rem; 
            font-weight: 500;
        }
        .btn-primary { 
             background-color: #334155; 
             color: white;
             border-color: #334155;
        }
        .btn-primary:hover {
            background-color: #1e293b; 
            border-color: #1e293b;
        }
        .btn-secondary { 
            background-color: #f1f5f9; 
            color: #334155; 
        }
        .btn-secondary:hover {
            background-color: #e2e8f0; 
        }
        .btn:disabled, .btn-secondary:disabled, .btn-primary:disabled, .btn-danger:disabled {
            background-color: #f8fafc !important; 
            color: #94a3b8 !important; 
            border-color: #e2e8f0 !important;
            cursor: not-allowed;
        }
         .btn-danger {
            background-color: #475569; 
            color: white;
            border-color: #475569;
        }
        .btn-danger:hover {
            background-color: #334155; 
            border-color: #334155;
        }

        #tsp-canvas {
            border: 1px solid #e2e8f0; 
            cursor: crosshair;
            background-color: #ffffff; 
            border-radius: 0.375rem; 
        }
        .dp-table-container { 
            max-height: 400px; 
            overflow-y: auto; 
            overflow-x: auto; 
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            margin-top: 0.5rem;
        }
        .dp-table td, .dp-table th {
            border: 1px solid #e2e8f0;
            padding: 0.3rem 0.4rem; 
            text-align: center;
            min-width: 40px; 
            font-size: 0.7rem; 
            white-space: nowrap;
        }
        .dp-table th {
            color: #475569;
            background-color: #f1f5f9; 
            font-weight: 500;
            position: sticky; 
            top: 0;
            z-index: 10;
        }
        .dp-table thead th:first-child { 
            left: 0;
            z-index: 20;
        }
        .dp-table tbody th { 
            position: sticky;
            left: 0;
            background-color: #f1f5f9; 
            z-index: 5;
        }

        .highlight-current { 
            background-color: #cbd5e1 !important; 
            color: #1e293b !important; 
            font-weight: 600;
        }
        .highlight-dependency { 
            background-color: #e0f2fe; 
            outline: 1px dotted #7dd3fc; 
        }
        .highlight-chosen-dependency { 
            background-color: #d1fae5; 
            outline: 1px solid #6ee7b7; 
        }
        .highlight-final-path { 
            stroke: #1e293b; 
            stroke-width: 2.5px !important;
        }

        .log-area {
            background-color: #f1f5f9; 
            border: 1px solid #e2e8f0; 
            padding: 0.75rem;
            min-height: 80px;
            font-size: 0.7rem; 
            white-space: pre-wrap;
            line-height: 1.5;
            max-height: 200px;
            overflow-y: auto;
            border-radius: 0.375rem;
        }
        .log-entry {
            margin-bottom: 0.3em;
            padding-bottom: 0.3em;
            border-bottom: 1px dashed #e2e8f0; 
        }
        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .accent-slate-500 { 
             accent-color: #64748b; 
        }
    </style>
</head>
<body>
    <div class="container mx-auto max-w-5xl container-card p-4 md:p-8 my-8">
        <header class="mb-8 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-700">TSP: Held-Karp Algorithm</h1>
            <p class="text-md text-slate-500 mt-1">Dynamic Programming Visualization</p>
        </header>

        <!-- Setup Section -->
        <section id="setup-section" class="mb-6">
            <h2 class="section-title">City Setup</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label for="num-cities" class="block label-text mb-1">Number of Cities (Max 5 for Vis):</label>
                    <input type="number" id="num-cities" value="4" min="2" max="5" class="input-field block w-full">
                </div>
                <div class="flex items-end">
                    <button id="generate-cities-btn" class="btn btn-secondary w-full">Generate Random Cities</button>
                </div>
            </div>
             <p class="text-xs text-slate-500">Alternatively, click on the canvas below to add cities (up to max).</p>
        </section>

        <!-- Controls Section -->
        <section id="controls-section" class="mb-6">
            <h2 class="section-title">Solver Controls</h2>
            <div class="flex flex-wrap gap-2 items-center">
                <button id="start-btn" class="btn btn-primary">Start</button>
                <button id="step-btn" class="btn btn-secondary" disabled>Step</button>
                <button id="auto-btn" class="btn btn-secondary" disabled>Auto</button> 
                <button id="pause-btn" class="btn btn-secondary" disabled>Pause</button>
                <button id="reset-btn" class="btn btn-danger">Reset</button>
                 <div class="flex items-center md:ml-auto mt-2 md:mt-0">
                    <label for="tsp-speed-slider" class="mr-2 label-text">Animation Speed:</label>
                    <input type="range" id="tsp-speed-slider" min="50" max="1500" value="500" step="50" class="w-24 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-slate-500">
                    <span id="tsp-speed-value" class="ml-2 text-xs text-slate-500 w-12 text-right">500ms</span>
                </div>
            </div>
        </section>

        <!-- Visualization Canvas -->
        <section class="mb-6">
            <h3 class="text-lg font-semibold mb-2 text-slate-700">City Map</h3>
            <canvas id="tsp-canvas" width="700" height="350"></canvas>
        </section>
        
        <!-- DP Table Section -->
        <section id="dp-table-section" class="mb-6">
            <h3 class="text-lg font-semibold mb-2 text-slate-700">DP Table (C[Subset, End_City])</h3>
            <div id="dp-table-container-held-karp" class="dp-table-container">
                <p class="text-center text-slate-400 py-4 text-sm">DP Table for Held-Karp will appear here.</p>
            </div>
        </section>

        <!-- Log and Results Section -->
        <section class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 class="section-title mb-2">Log</h3>
                <div id="tsp-log-area" class="log-area">
                    <p class="text-slate-400">Log messages will appear here...</p>
                </div>
            </div>
            <div>
                <h3 class="section-title mb-2">Results</h3>
                <p id="tsp-path-output" class="text-slate-700 text-sm">Optimal Path: <span class="font-semibold">-</span></p>
                <p id="tsp-distance-output" class="text-slate-700 text-sm">Total Distance: <span class="font-semibold">-</span></p>
            </div>
        </section>

        <footer class="mt-8 pt-4 border-t border-slate-200 text-center">
            <p class="text-xs text-slate-400">&copy; TSP Held-Karp Visualizer</p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('tsp-canvas');
        const ctx = canvas.getContext('2d');
        const numCitiesInput = document.getElementById('num-cities');
        const generateCitiesBtn = document.getElementById('generate-cities-btn');
        const startBtn = document.getElementById('start-btn');
        const stepBtn = document.getElementById('step-btn');
        const autoBtn = document.getElementById('auto-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const speedSlider = document.getElementById('tsp-speed-slider');
        const speedValueSpan = document.getElementById('tsp-speed-value');
        const logArea = document.getElementById('tsp-log-area');
        const pathOutput = document.getElementById('tsp-path-output').querySelector('span');
        const distanceOutput = document.getElementById('tsp-distance-output').querySelector('span');
        const dpTableContainerHeldKarp = document.getElementById('dp-table-container-held-karp');
        // const inputError = document.getElementById('input-error'); // This element does not exist in this HTML.

        let cities = []; 
        let cityIdCounter = 0;
        let N = 0; 
        let distMatrix = [];
        let dp_HK = {}; 
        let path_HK = {}; 
        let dpTableElements_HK = {}; 

        let isSolving_HK = false;
        let isPaused_HK = false;
        let animationSpeed_HK = 500;
        let autoplayIntervalId_HK = null;
        let currentStepGenerator_HK = null; 

        const CITY_RADIUS = 7;
        const GRID_SPACING = 50;
        const GRID_COLOR = "#e2e8f0"; 
        const CITY_COLOR_DEFAULT = "#64748b"; 
        const CITY_TEXT_COLOR = "#1e293b"; 
        const CITY_COLOR_START_END = "#cbd5e1";     
        const CITY_BORDER_START_END = "#475569";  
        
        const PATH_COLOR_TOUR = "#334155";   
        const PATH_COLOR_CALC_EDGE = "#60a5fa"; 

        function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

        function addLog(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            if (logArea.firstChild && logArea.firstChild.textContent === "Log messages will appear here...") {
                logArea.innerHTML = '';
            }
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function drawGrid() {
            ctx.strokeStyle = GRID_COLOR; ctx.lineWidth = 0.5;
            for (let x = GRID_SPACING; x < canvas.width; x += GRID_SPACING) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
            for (let y = GRID_SPACING; y < canvas.height; y += GRID_SPACING) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
        }

        function drawCityCircles() {
            cities.forEach((city, index) => {
                ctx.beginPath();
                ctx.arc(city.x, city.y, CITY_RADIUS, 0, Math.PI * 2);
                let fillColor = CITY_COLOR_DEFAULT;
                let strokeStyle = null;
                if (index === 0) { 
                    fillColor = CITY_COLOR_START_END;
                    strokeStyle = CITY_BORDER_START_END;
                }
                ctx.fillStyle = fillColor;
                ctx.fill();
                if (strokeStyle) {
                    ctx.strokeStyle = strokeStyle;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                ctx.closePath();
            });
        }
        
        function drawCityLabels() {
            cities.forEach((city) => {
                ctx.fillStyle = CITY_TEXT_COLOR; 
                ctx.font = "bold 10px Inter"; 
                ctx.textAlign = "center";
                ctx.fillText(city.id, city.x, city.y + CITY_RADIUS + 9); 
            });
        }

        function drawPath(pathIndices, color, lineWidth) {
            if (!pathIndices || pathIndices.length < 2) return;
            const firstCityIndex = pathIndices[0];
            if (!cities[firstCityIndex]) return; 

            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(cities[firstCityIndex].x, cities[firstCityIndex].y);
            for (let i = 1; i < pathIndices.length; i++) {
                 const cityIndex = pathIndices[i];
                 if (cities[cityIndex]) {
                    ctx.lineTo(cities[cityIndex].x, cities[cityIndex].y);
                 } else {
                    console.warn(`City at index ${cityIndex} not found for drawing path.`);
                    break; 
                 }
            }
            ctx.stroke();
        }
        
        function redrawCanvas(currentPath = null, currentCalcEdge = null, finalOptimalPath = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            drawCityCircles(); 

            if (finalOptimalPath && finalOptimalPath.length > 0) {
                drawPath(finalOptimalPath, PATH_COLOR_TOUR, 2.5); 
                if (finalOptimalPath.length === N && cities[finalOptimalPath[0]]) {
                    drawPath([finalOptimalPath[finalOptimalPath.length - 1], finalOptimalPath[0]], PATH_COLOR_TOUR, 2.5);
                }
            } else if (currentPath && currentPath.length > 0) { 
                drawPath(currentPath, PATH_COLOR_DEFAULT, 1.5);
            }
            
            if (currentCalcEdge && cities[currentCalcEdge.from] && cities[currentCalcEdge.to]) { 
                 drawPath([currentCalcEdge.from, currentCalcEdge.to], currentCalcEdge.color, 2);
            }
            
            drawCityLabels(); 
        }

        canvas.addEventListener('click', (event) => {
            if (isSolving_HK || cities.length >= parseInt(numCitiesInput.max)) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            cities.push({ x, y, id: cityIdCounter }); 
            cityIdCounter++;
            N = cities.length;
            redrawCanvas();
            addLog(`Added City ${cityIdCounter-1} at (${x.toFixed(0)}, ${y.toFixed(0)})`);
        });

        generateCitiesBtn.addEventListener('click', () => {
            if (isSolving_HK) return;
            cities = [];
            cityIdCounter = 0;
            N = Math.min(parseInt(numCitiesInput.value), parseInt(numCitiesInput.max)); 
            numCitiesInput.value = N; 

            for (let i = 0; i < N; i++) {
                cities.push({
                    x: Math.random() * (canvas.width - 2 * (CITY_RADIUS + 10)) + (CITY_RADIUS + 10),
                    y: Math.random() * (canvas.height - 2 * (CITY_RADIUS + 10)) + (CITY_RADIUS + 10),
                    id: cityIdCounter++
                });
            }
            redrawCanvas();
            addLog(`Generated ${N} random cities.`);
            resetSolutionUI();
        });
        
        resetBtn.addEventListener('click', resetSolutionFull);

        speedSlider.addEventListener('input', (e) => {
            animationSpeed_HK = parseInt(e.target.value);
            speedValueSpan.textContent = `${animationSpeed_HK}ms`;
        });
        
        function resetSolutionUI(){
            pathOutput.textContent = "-";
            distanceOutput.textContent = "-";
            dp_HK = {};
            path_HK = {};
            dpTableElements_HK = {};
            dpTableContainerHeldKarp.innerHTML = '<p class="text-center text-slate-400 py-4 text-sm">DP Table for Held-Karp will appear here.</p>';
            redrawCanvas(); 
        }

        function resetSolutionFull() {
            if (autoplayIntervalId_HK) clearInterval(autoplayIntervalId_HK);
            autoplayIntervalId_HK = null;
            isSolving_HK = false;
            isPaused_HK = false;
            currentStepGenerator_HK = null;
            
            cities = []; 
            cityIdCounter = 0;
            N = 0;
            resetSolutionUI(); 

            logArea.innerHTML = ''; 
            addLog("System reset. Add or generate cities.");

            startBtn.disabled = false;
            generateCitiesBtn.disabled = false;
            stepBtn.disabled = true;
            autoBtn.disabled = true;
            pauseBtn.disabled = true;
            numCitiesInput.value = "4"; // Reset num cities input
            speedSlider.value = "500";
            animationSpeed_HK = 500;
            speedValueSpan.textContent = `${animationSpeed_HK}ms`;
            // if (inputError) inputError.textContent = ""; // Only if inputError element exists
        }
        
        function calculateDistanceMatrix() {
            distMatrix = Array(N).fill(null).map(() => Array(N).fill(0));
            for (let i = 0; i < N; i++) {
                for (let j = i; j < N; j++) {
                    if (i === j) continue;
                    const d = Math.sqrt(Math.pow(cities[i].x - cities[j].x, 2) + Math.pow(cities[i].y - cities[j].y, 2));
                    distMatrix[i][j] = d;
                    distMatrix[j][i] = d;
                }
            }
        }

        function getSubsetCities(mask) {
            const subset = [];
            for (let i = 0; i < N; i++) {
                if ((mask >> i) & 1) subset.push(i);
            }
            return subset;
        }
        
        function initializeHeldKarpDPTableHTML() {
            dpTableContainerHeldKarp.innerHTML = '';
            const table = document.createElement('table');
            table.className = 'dp-table w-full border-collapse';
            const header = table.createTHead().insertRow();
            const thCorner = document.createElement('th');
            thCorner.innerHTML = 'Subset {Cities}<span class="text-xs text-slate-400">\\EndAt</span>';
            header.appendChild(thCorner);

            for (let j = 0; j < N; j++) { 
                const th = document.createElement('th');
                th.textContent = `City ${j}`;
                header.appendChild(th);
            }
            
            const tbody = table.createTBody();
            dpTableElements_HK = {}; 

            for (let mask = 1; mask < (1 << N); mask++) {
                if (!((mask >> 0) & 1)) continue; 

                const subset = getSubsetCities(mask);
                if (subset.length === 0) continue; 

                const row = tbody.insertRow();
                const thSubset = document.createElement('th');
                thSubset.textContent = `{${subset.join(',')}} (m:${mask.toString(2).padStart(N, '0')})`;
                row.appendChild(thSubset);

                dpTableElements_HK[mask] = {};
                for (let j = 0; j < N; j++) {
                    const cell = row.insertCell();
                    cell.textContent = '∞';
                    if (!((mask >> j) & 1) || (mask === (1 << 0) && j !== 0) ) { 
                        cell.textContent = '-';
                        cell.classList.add('text-slate-300');
                    }
                    dpTableElements_HK[mask][j] = cell;
                }
            }
            dpTableContainerHeldKarp.appendChild(table);
        }
        
        function clearAllHighlights() {
            for (const maskKey in dpTableElements_HK) {
                for (const endCityKey in dpTableElements_HK[maskKey]) {
                    const cell = dpTableElements_HK[maskKey][endCityKey];
                    if (cell) {
                         cell.classList.remove('highlight-current', 'highlight-dependency', 'highlight-chosen-dependency');
                    }
                }
            }
            redrawCanvas(); 
        }

        async function* heldKarpGenerator() {
            calculateDistanceMatrix();
            initializeHeldKarpDPTableHTML();
            dp_HK = {}; 
            path_HK = {};

            const startNodeMask = 1 << 0; 
            dp_HK[startNodeMask] = {};
            dp_HK[startNodeMask][0] = 0;
            if (dpTableElements_HK[startNodeMask] && dpTableElements_HK[startNodeMask][0]) {
                 dpTableElements_HK[startNodeMask][0].textContent = '0';
                 dpTableElements_HK[startNodeMask][0].classList.add('highlight-calculated', 'text-item-included');
            }
            addLog(`Base case: dp[{0} (mask ${startNodeMask.toString(2).padStart(N,'0')})][0] = 0`);
            yield; 

            for (let s = 2; s <= N; s++) {
                addLog(`\nProcessing subsets of size ${s}:`);
                for (let mask = 1; mask < (1 << N); mask++) {
                    if (!((mask >> 0) & 1)) continue; 
                    
                    const subset = getSubsetCities(mask);
                    if (subset.length !== s) continue;

                    if (!dp_HK[mask]) dp_HK[mask] = {};
                    if (!path_HK[mask]) path_HK[mask] = {};

                    for (const j of subset) { 
                        if (j === 0 && s > 1) continue; 
                        
                        clearAllHighlights();
                        if (dpTableElements_HK[mask] && dpTableElements_HK[mask][j]) {
                            dpTableElements_HK[mask][j].classList.add('highlight-current');
                        }
                        addLog(`  Calculating dp[{${subset.join(',')}}][${j}]:`);
                        yield; 
                        
                        let minCostForCurrentCell = Infinity;
                        let bestPrevK = -1;

                        const prevMask = mask ^ (1 << j); 
                        if (!((prevMask >> 0) & 1) && prevMask !== 0 && N > 1) continue; 
                        
                        const prevSubset = getSubsetCities(prevMask);

                        for (const k of prevSubset) { 
                            if (dp_HK[prevMask] && dp_HK[prevMask][k] !== undefined && dp_HK[prevMask][k] !== Infinity) {
                                const cost = dp_HK[prevMask][k] + distMatrix[k][j];
                                addLog(`    Trying path ...${k} -> ${j}. Cost = (dp[{${prevSubset.join(',')}}][${k}]=${dp_HK[prevMask][k].toFixed(1)}) + dist(${k},${j}=${distMatrix[k][j].toFixed(1)}) = ${cost.toFixed(1)}`);
                                
                                if (dpTableElements_HK[prevMask] && dpTableElements_HK[prevMask][k]) {
                                    dpTableElements_HK[prevMask][k].classList.add('highlight-dependency');
                                }
                                redrawCanvas(null, {from: k, to: j, color: PATH_COLOR_CALC_EDGE});
                                yield; 

                                if (cost < minCostForCurrentCell) {
                                    minCostForCurrentCell = cost;
                                    bestPrevK = k;
                                }
                                if (dpTableElements_HK[prevMask] && dpTableElements_HK[prevMask][k]) {
                                    dpTableElements_HK[prevMask][k].classList.remove('highlight-dependency');
                                }
                            }
                        }
                        
                        dp_HK[mask][j] = minCostForCurrentCell;
                        path_HK[mask][j] = bestPrevK; 

                        if (dpTableElements_HK[mask] && dpTableElements_HK[mask][j]) {
                            dpTableElements_HK[mask][j].textContent = dp_HK[mask][j] === Infinity ? '∞' : dp_HK[mask][j].toFixed(1);
                            dpTableElements_HK[mask][j].classList.remove('highlight-current');
                            dpTableElements_HK[mask][j].classList.add('highlight-calculated', dp_HK[mask][j] === Infinity ? 'text-item-not-included' : 'text-item-included');
                            if (bestPrevK !== -1 && dpTableElements_HK[prevMask] && dpTableElements_HK[prevMask][bestPrevK]) {
                                 dpTableElements_HK[prevMask][bestPrevK].classList.add('highlight-chosen-dependency');
                            }
                        }
                        addLog(`  -> dp[{${subset.join(',')}}][${j}] = ${dp_HK[mask][j] === Infinity ? '∞' : dp_HK[mask][j].toFixed(1)} (via city ${bestPrevK})`);
                        redrawCanvas(); 
                        yield; 
                        if (bestPrevK !== -1 && dpTableElements_HK[prevMask] && dpTableElements_HK[prevMask][bestPrevK]) {
                            dpTableElements_HK[prevMask][bestPrevK].classList.remove('highlight-chosen-dependency');
                        }
                    }
                }
            }
            
            const finalMask = (1 << N) - 1; 
            let minTotalCost = Infinity;
            let lastCityBeforeReturning = -1;

            addLog("\nFinal step: Calculating return to start city 0:");
            if (!dp_HK[finalMask] && N > 1) { 
                 addLog("Error: DP state for all cities visited is missing.");
                 return; 
            }
            if (N === 1) { 
                 minTotalCost = 0;
                 lastCityBeforeReturning = 0; 
                 addLog(`  Single city tour. Cost: 0`);
                 yield;
            } else {
                for (let j = 1; j < N; j++) { 
                    clearAllHighlights();
                    if (dp_HK[finalMask] && dp_HK[finalMask][j] !== undefined && dp_HK[finalMask][j] !== Infinity) {
                        const cost = dp_HK[finalMask][j] + distMatrix[j][0];
                        addLog(`  Path ending at ${j}, then to 0: (dp[all][${j}]=${dp_HK[finalMask][j].toFixed(1)}) + dist(${j},0=${distMatrix[j][0].toFixed(1)}) = ${cost.toFixed(1)}`);
                        if (dpTableElements_HK[finalMask] && dpTableElements_HK[finalMask][j]) {
                             dpTableElements_HK[finalMask][j].classList.add('highlight-dependency');
                        }
                        redrawCanvas(null, {from: j, to: 0, color: PATH_COLOR_CALC_EDGE});
                        yield;

                        if (cost < minTotalCost) {
                            minTotalCost = cost;
                            lastCityBeforeReturning = j;
                        }
                    }
                }
            }
            redrawCanvas(); 

            if (lastCityBeforeReturning !== -1 && N > 1 && dpTableElements_HK[finalMask] && dpTableElements_HK[finalMask][lastCityBeforeReturning]) {
                dpTableElements_HK[finalMask][lastCityBeforeReturning].classList.add('highlight-chosen-dependency');
            }
            addLog(`-> Minimum total tour cost: ${minTotalCost === Infinity ? 'N/A' : minTotalCost.toFixed(1)} (last city before returning to 0 is ${lastCityBeforeReturning})`);
            yield; 

            let reconstructedPath = [];
            if (minTotalCost !== Infinity) {
                let curr = lastCityBeforeReturning;
                let mask = finalMask;
                while (curr !== undefined && curr !== -1 && mask !== 0) {
                    reconstructedPath.unshift(curr);
                    if (mask === (1 << curr) && curr === 0) break; 
                    
                    const prev = path_HK[mask] ? path_HK[mask][curr] : -1; 
                    if (prev === undefined || prev === -1) { 
                        if (mask !== (1 << curr)) { 
                             addLog(`Warning: Path reconstruction issue. Could not find predecessor for city ${curr} in mask ${mask.toString(2)}.`);
                        }
                        break; 
                    }
                    mask ^= (1 << curr);
                    curr = prev;
                }
                 if (N > 1 && (reconstructedPath.length === 0 || reconstructedPath[0] !== 0)) { 
                    if (!reconstructedPath.includes(0)) reconstructedPath.unshift(0);
                 } else if (N === 1 && reconstructedPath.length === 0) {
                    reconstructedPath.push(0);
                 }


                addLog("Reconstructed path (indices): " + reconstructedPath.join(' -> '));
                redrawCanvas(null, null, reconstructedPath);
                pathOutput.textContent = reconstructedPath.map(idx => cities[idx]? cities[idx].id : '?').join(' -> ') + (reconstructedPath.length > 0 && cities[reconstructedPath[0]] ? ` -> ${cities[reconstructedPath[0]].id}` : "");
                distanceOutput.textContent = minTotalCost.toFixed(2);
            } else {
                 pathOutput.textContent = "N/A";
                 distanceOutput.textContent = "N/A";
            }
            yield; 
        }

        
        async function processStep_HK() {
            if (!currentStepGenerator_HK || !isSolving_HK) return;
            
            stepBtn.disabled = true; 
            autoBtn.disabled = true;

            const result = await currentStepGenerator_HK.next();
            
            if (result.done) {
                finalizeSolution_HK();
            } else if (isSolving_HK && isPaused_HK) { 
                stepBtn.disabled = false;
                autoBtn.disabled = false;
                pauseBtn.disabled = true;
            } else if (isSolving_HK && !isPaused_HK && autoplayIntervalId_HK) { 
                 stepBtn.disabled = true;
                 autoBtn.disabled = true;
                 pauseBtn.disabled = false;
            }
        }

        function startExecution_HK() {
            if (cities.length < 1) { // Allow N=1 for Held-Karp base case
                addLog("Add at least 1 city."); return;
            }
             if (cities.length > parseInt(numCitiesInput.max)) {
                addLog(`Max ${numCitiesInput.max} cities for Held-Karp visualization.`); return;
            }

            isSolving_HK = true;
            isPaused_HK = false;
            
            logArea.innerHTML = '';
            // treeVisualizationArea.innerHTML = ''; // DP Table container is separate
            // if(treePlaceholder) treePlaceholder.style.display = 'block'; // Not used for DP table
            addLog("--- Starting Held-Karp Algorithm ---");

            pathOutput.textContent = "-";
            distanceOutput.textContent = "-";
            
            currentStepGenerator_HK = heldKarpGenerator();
            startAutoplay_HK(); 
        }

        function startAutoplay_HK() {
            if (autoplayIntervalId_HK) clearInterval(autoplayIntervalId_HK);
            isPaused_HK = false;
            
            startBtn.disabled = true;
            stepBtn.disabled = true;
            autoBtn.disabled = true;
            pauseBtn.disabled = false;
            resetBtn.disabled = false; 
            generateCitiesBtn.disabled = true;

            addLog("Autoplay started...");
            
            autoplayIntervalId_HK = setInterval(async () => {
                try {
                    if (isPaused_HK) return; 
                    await processStep_HK(); 
                } catch (e) {
                     console.error("Error in Held-Karp autoplay interval:", e);
                     addLog("RUNTIME ERROR in autoplay: " + e.message);
                     if(autoplayIntervalId_HK) clearInterval(autoplayIntervalId_HK);
                     finalizeSolution_HK(); 
                }
            }, animationSpeed_HK);
        }

        function pauseAutoplay_HK() {
            if (autoplayIntervalId_HK) clearInterval(autoplayIntervalId_HK);
            autoplayIntervalId_HK = null;
            isPaused_HK = true;
            addLog("--- Autoplay Paused ---");

            if (isSolving_HK) { 
                startBtn.disabled = true;
                stepBtn.disabled = false;
                autoBtn.disabled = false;
                pauseBtn.disabled = true;
                resetBtn.disabled = false;
                generateCitiesBtn.disabled = true; 
            }
        }
        
        function finalizeSolution_HK() {
            if (autoplayIntervalId_HK) clearInterval(autoplayIntervalId_HK);
            autoplayIntervalId_HK = null;
            isSolving_HK = false;
            isPaused_HK = false;
            currentStepGenerator_HK = null;
            addLog("--- Held-Karp Algorithm Finished ---");
            
            startBtn.disabled = false;
            stepBtn.disabled = true;
            autoBtn.disabled = true;
            pauseBtn.disabled = true;
            resetBtn.disabled = false;
            generateCitiesBtn.disabled = false;
        }

        function resetAll() {
            if (autoplayIntervalId_HK) clearInterval(autoplayIntervalId_HK);
            autoplayIntervalId_HK = null;
            isSolving_HK = false;
            isPaused_HK = false;
            currentStepGenerator_HK = null;
            
            numCitiesInput.value = "4"; 
            speedSlider.value = "500"; 
            animationSpeed_HK = 500;
            speedValueSpan.textContent = `${animationSpeed_HK}ms`;

            // inputError.textContent = ""; // No inputError element in this HTML
            dpTableContainerHeldKarp.innerHTML = '<p class="text-center text-slate-400 py-4 text-sm">DP Table for Held-Karp will appear here.</p>';


            logArea.innerHTML = ''; 
            addLog("Log messages will appear here..."); 
            
            pathOutput.textContent = "-";
            distanceOutput.textContent = "-";

            cities = [];
            cityIdCounter = 0;
            N = 0;
            distMatrix = [];
            dp_HK = {};
            path_HK = {};
            dpTableElements_HK = {};

            startBtn.disabled = false;
            stepBtn.disabled = true;
            autoBtn.disabled = true;
            pauseBtn.disabled = true;
            resetBtn.disabled = false;
            generateCitiesBtn.disabled = false;
            redrawCanvas();
        }

        // Event Listeners
        speedSlider.addEventListener('input', (e) => {
            animationSpeed_HK = parseInt(e.target.value);
            speedValueSpan.textContent = `${animationSpeed_HK}ms`;
        });
        
        startBtn.addEventListener('click', startExecution_HK);
        stepBtn.addEventListener('click', processStep_HK);
        autoBtn.addEventListener('click', () => { 
            if(isSolving_HK && isPaused_HK){
                startAutoplay_HK();
            } else if (!isSolving_HK) {
                startExecution_HK(); 
            }
        });
        pauseBtn.addEventListener('click', pauseAutoplay_HK);
        resetBtn.addEventListener('click', resetAll);
        
        // Initial call
        resetAll();
        generateCitiesBtn.click(); 

    </script>
</body>
</html>
