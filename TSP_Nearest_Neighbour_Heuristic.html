<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP - Nearest Neighbour Visualization</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
            color: #1e293b; /* slate-800 */
            font-size: 0.875rem;
        }
        .container-card {
            background-color: #ffffff;
            border: 1px solid #e2e8f0; /* slate-200 */
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.07), 0 2px 4px -2px rgb(0 0 0 / 0.07);
        }
        .section-title {
            color: #334155; /* slate-700 */
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
            font-size: 1.125rem;
            font-weight: 600;
        }
        .label-text {
            color: #475569; /* slate-600 */
            font-size: 0.8rem;
        }
        .input-field {
            background-color: #f8fafc;
            color: #1e293b;
            border: 1px solid #cbd5e1; /* slate-300 */
            padding: 0.625rem;
            font-size: 0.8rem;
            border-radius: 0.375rem;
        }
        .input-field:focus {
            border-color: #64748b; /* slate-500 */
            box-shadow: 0 0 0 2px rgba(100, 116, 139, 0.2);
            outline: none;
        }
        /* Button Styles from Knapsack Minimalist */
        .btn {
            padding: 0.5rem 1rem; 
            border: 1px solid #cbd5e1; /* slate-300 default border */
            transition: background-color 0.2s, color 0.2s;
            font-size: 0.75rem; 
            border-radius: 0.375rem; /* rounded-md */
            font-weight: 500;
        }
        .btn-primary { 
             background-color: #334155; /* slate-700 */
             color: white;
             border-color: #334155;
        }
        .btn-primary:hover {
            background-color: #1e293b; /* slate-800 */
            border-color: #1e293b;
        }
        .btn-secondary { 
            background-color: #f1f5f9; /* slate-100 */
            color: #334155; /* slate-700 */
        }
        .btn-secondary:hover {
            background-color: #e2e8f0; /* slate-200 */
        }
        .btn:disabled, .btn-secondary:disabled, .btn-primary:disabled, .btn-danger:disabled { /* Combined disabled styles */
            background-color: #f8fafc !important; 
            color: #94a3b8 !important; /* slate-400 */
            border-color: #e2e8f0 !important;
            cursor: not-allowed;
        }
         .btn-danger {
            background-color: #475569; /* slate-600 */
            color: white;
            border-color: #475569;
        }
        .btn-danger:hover {
            background-color: #334155; /* slate-700 */
            border-color: #334155;
        }

        #tsp-canvas {
            border: 1px solid #e2e8f0; /* slate-200 */
            cursor: crosshair;
            background-color: #f8fafc; /* slate-50 */
            border-radius: 0.375rem; /* rounded-md */
        }
        .log-area {
            background-color: #f1f5f9; /* slate-100 */
            border: 1px solid #e2e8f0; /* slate-200 */
            padding: 0.75rem;
            min-height: 60px;
            font-size: 0.75rem;
            white-space: pre-wrap;
            line-height: 1.6;
            max-height: 150px;
            overflow-y: auto;
            border-radius: 0.375rem;
        }
        .log-entry {
            margin-bottom: 0.3em;
            padding-bottom: 0.3em;
            border-bottom: 1px dashed #e2e8f0; /* slate-200 */
        }
        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .accent-slate-500 { /* For range slider thumb */
             accent-color: #64748b; 
        }
    </style>
</head>
<body>
    <div class="container mx-auto max-w-4xl container-card p-4 md:p-8 my-8">
        <header class="mb-8 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-slate-700">Travelling Salesperson Problem</h1>
            <p class="text-md text-slate-500 mt-1">Nearest Neighbour Heuristic Visualization</p>
        </header>

        <!-- Setup Section -->
        <section id="setup-section" class="mb-6">
            <h2 class="section-title">City Setup</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label for="num-cities" class="block label-text mb-1">Number of Random Cities:</label>
                    <input type="number" id="num-cities" value="10" min="3" max="50" class="input-field block w-full">
                </div>
                <div class="md:col-span-2 flex items-end">
                    <button id="generate-cities-btn" class="btn btn-secondary w-full">Generate Random Cities</button>
                </div>
            </div>
             <p class="text-xs text-slate-500">Alternatively, click on the canvas below to add cities manually.</p>
        </section>

        <!-- Controls Section -->
        <section id="controls-section" class="mb-6">
            <h2 class="section-title">Solver Controls</h2>
            <div class="flex flex-wrap gap-2 items-center">
                <button id="start-btn" class="btn btn-primary">Start</button> 
                <button id="step-btn" class="btn btn-secondary" disabled>Step</button> 
                <button id="auto-btn" class="btn btn-secondary" disabled>Auto</button>  
                <button id="pause-btn" class="btn btn-secondary" disabled>Pause</button> 
                <button id="reset-btn" class="btn btn-danger">Reset</button> 
                 <div class="flex items-center md:ml-auto mt-2 md:mt-0">
                    <label for="tsp-speed-slider" class="mr-2 label-text">Animation Speed:</label>
                    <input type="range" id="tsp-speed-slider" min="50" max="1000" value="300" step="50" class="w-24 h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-slate-500">
                    <span id="tsp-speed-value" class="ml-2 text-xs text-slate-500 w-12 text-right">300ms</span>
                </div>
            </div>
        </section>

        <!-- Visualization Canvas -->
        <section class="mb-6">
            <h3 class="text-lg font-semibold mb-2 text-slate-700">City Map</h3>
            <canvas id="tsp-canvas" width="700" height="400"></canvas>
        </section>

        <!-- Log and Results Section -->
        <section class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 class="section-title mb-2">Log</h3>
                <div id="tsp-log-area" class="log-area">
                    <p class="text-slate-400">Log messages will appear here...</p>
                </div>
            </div>
            <div>
                <h3 class="section-title mb-2">Results</h3>
                <p id="tsp-path-output" class="text-slate-700 text-sm">Path: <span class="font-semibold">-</span></p>
                <p id="tsp-distance-output" class="text-slate-700 text-sm">Total Distance: <span class="font-semibold">-</span></p>
            </div>
        </section>

        <footer class="mt-8 pt-4 border-t border-slate-200 text-center">
            <p class="text-xs text-slate-400">&copy; TSP Visualizer</p>
        </footer>
    </div>

    <script>
        const canvas = document.getElementById('tsp-canvas');
        const ctx = canvas.getContext('2d');
        const numCitiesInput = document.getElementById('num-cities');
        const generateCitiesBtn = document.getElementById('generate-cities-btn');
        
        const startBtn = document.getElementById('start-btn'); 
        const stepBtn = document.getElementById('step-btn');   
        const autoBtn = document.getElementById('auto-btn');     
        const pauseBtn = document.getElementById('pause-btn');   
        const resetBtn = document.getElementById('reset-btn'); 
        
        const speedSlider = document.getElementById('tsp-speed-slider');
        const speedValueSpan = document.getElementById('tsp-speed-value');
        const logArea = document.getElementById('tsp-log-area');
        const pathOutput = document.getElementById('tsp-path-output').querySelector('span');
        const distanceOutput = document.getElementById('tsp-distance-output').querySelector('span');

        let cities = []; 
        let tour = []; // Stores indices of cities in the tour
        let totalDistance = 0;
        
        let isSolving = false; 
        let isPaused = false; 
        let animationSpeed = 300;
        let cityIdCounter = 0;
        
        let currentCityIndex_TSP; // For TSP state
        let visited_TSP_Map; // Map for O(1) lookup: city_index -> boolean
        let tsp_step_count; // How many cities added to tour so far
        let autoplayIntervalId_TSP = null;


        const CITY_RADIUS = 6; 
        const GRID_SPACING = 50;
        const GRID_COLOR = "#e2e8f0"; 

        const CITY_COLOR_UNVISITED = "#64748b"; 
        const CITY_TEXT_UNVISITED = "#f8fafc";   
        const CITY_COLOR_VISITED = "#94a3b8";   
        const CITY_TEXT_VISITED = "#1e293b";    
        const CITY_COLOR_CURRENT = "#334155";   
        const CITY_TEXT_CURRENT = "#f8fafc";    
        const CITY_COLOR_START = "#cbd5e1";     
        const CITY_BORDER_START = "#475569";  
        const CITY_TEXT_START = "#1e293b";      
        
        const PATH_COLOR_DEFAULT = "#94a3b8";   
        const PATH_COLOR_HIGHLIGHT = "#1e293b"; 


        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function addLog(message) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            if (logArea.firstChild && logArea.firstChild.textContent === "Log messages will appear here...") {
                logArea.innerHTML = '';
            }
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }

        function drawGrid() {
            ctx.beginPath();
            ctx.strokeStyle = GRID_COLOR;
            ctx.lineWidth = 0.5; 

            for (let x = GRID_SPACING; x < canvas.width; x += GRID_SPACING) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            for (let y = GRID_SPACING; y < canvas.height; y += GRID_SPACING) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            ctx.stroke();
            ctx.closePath();
        }

        function drawCities() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid(); 

            cities.forEach((city, index) => { // Use index directly
                ctx.beginPath();
                ctx.arc(city.x, city.y, CITY_RADIUS, 0, Math.PI * 2);

                let fillColor = CITY_COLOR_UNVISITED;
                let textColor = CITY_TEXT_UNVISITED; // Default for unvisited
                let strokeStyle = null; 
                
                const isStartCity = index === tour[0]; // Check if this city is the start of the current tour
                
                if (isStartCity && visited_TSP_Map && visited_TSP_Map.has(index)) { // Visited start city
                    fillColor = CITY_COLOR_START;
                    textColor = CITY_TEXT_START;
                    strokeStyle = CITY_BORDER_START;
                } else if (index === currentCityIndex_TSP) { // Current city in processing
                    fillColor = CITY_COLOR_CURRENT;
                    textColor = CITY_TEXT_CURRENT;
                } else if (visited_TSP_Map && visited_TSP_Map.has(index)) { // Other visited cities
                    fillColor = CITY_COLOR_VISITED;
                    textColor = CITY_TEXT_VISITED;
                }
                // Else, it's unvisited, uses default unvisited colors.
                
                ctx.fillStyle = fillColor;
                ctx.fill();
                if (strokeStyle) {
                    ctx.strokeStyle = strokeStyle;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                ctx.closePath();

                ctx.fillStyle = textColor;
                ctx.font = "9px Inter"; 
                ctx.textAlign = "center";
                ctx.fillText(city.id, city.x, city.y + CITY_RADIUS + 8); 
            });
        }

        function drawCurrentTourPath() { 
            if (tour.length < 2) return;

            ctx.strokeStyle = PATH_COLOR_DEFAULT;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(cities[tour[0]].x, cities[tour[0]].y);
            for (let i = 1; i < tour.length; i++) {
                if (cities[tour[i]]) { 
                    ctx.lineTo(cities[tour[i]].x, cities[tour[i]].y);
                }
            }
            ctx.stroke();

            // If it's the final tour (all cities visited), draw return to start
            if (tsp_step_count >= cities.length && tour.length > 0 && cities[tour[0]]) { 
                 ctx.lineTo(cities[tour[0]].x, cities[tour[0]].y);
                 ctx.stroke();
            }
        }

        function redrawCanvasWithCurrentTour() {
            drawCities();
            drawCurrentTourPath();
        }
        
        function highlightSegment(cityIndex1, cityIndex2) {
            if (cityIndex1 === undefined || cityIndex2 === undefined || !cities[cityIndex1] || !cities[cityIndex2]) return;
            redrawCanvasWithCurrentTour(); // Redraw existing cities and tour path
            ctx.strokeStyle = PATH_COLOR_HIGHLIGHT;
            ctx.lineWidth = 2; 
            ctx.beginPath();
            ctx.moveTo(cities[cityIndex1].x, cities[cityIndex1].y);
            ctx.lineTo(cities[cityIndex2].x, cities[cityIndex2].y);
            ctx.stroke();
        }

        canvas.addEventListener('click', (event) => {
            if (isSolving) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            cities.push({ x, y, id: ++cityIdCounter }); // Removed visited, isCurrent from here
            drawCities(); // Just draw cities, no tour yet
            addLog(`Added city ${cityIdCounter} at (${x.toFixed(0)}, ${y.toFixed(0)})`);
        });

        generateCitiesBtn.addEventListener('click', () => {
            if (isSolving) return;
            cities = [];
            cityIdCounter = 0;
            const num = parseInt(numCitiesInput.value);
            for (let i = 0; i < num; i++) {
                cities.push({
                    x: Math.random() * (canvas.width - 2 * (CITY_RADIUS + 5)) + (CITY_RADIUS + 5), 
                    y: Math.random() * (canvas.height - 2 * (CITY_RADIUS + 5)) + (CITY_RADIUS + 5),
                    id: ++cityIdCounter
                });
            }
            resetSolutionFull(false); // Reset solution but not cities
            drawCities();
            addLog(`Generated ${num} random cities.`);
        });
        
        resetBtn.addEventListener('click', () => resetSolutionFull(true));

        speedSlider.addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value);
            speedValueSpan.textContent = `${animationSpeed}ms`;
        });
        
        function initializeTSPState() {
            tour = [];
            totalDistance = 0;
            visited_TSP_Map = new Map();
            tsp_step_count = 0;

            if (cities.length === 0) return false;

            currentCityIndex_TSP = 0; // Start with the first city (index 0)
            visited_TSP_Map.set(currentCityIndex_TSP, true);
            tour.push(currentCityIndex_TSP);
            tsp_step_count = 1;
            
            pathOutput.textContent = "-";
            distanceOutput.textContent = "-";
            logArea.innerHTML = '';
            addLog(`TSP Initialized. Starting at City ${cities[currentCityIndex_TSP].id}.`);
            redrawCanvasWithCurrentTour();
            return true;
        }


        function resetSolutionUI(){ 
            tour = [];
            totalDistance = 0;
             if (cities) { // Only if cities exist
                cities.forEach(c => { 
                    if(c) { // Check if city object itself is defined
                        c.visited = false; 
                        c.isCurrent = false;
                    }
                });
            }
            currentCityIndex_TSP = undefined;
            visited_TSP_Map = new Map();
            tsp_step_count = 0;

            pathOutput.textContent = "-";
            distanceOutput.textContent = "-";
            redrawCanvasWithCurrentTour();
        }

        function resetSolutionFull(clearCityData = true) { 
            if (autoplayIntervalId_TSP) clearInterval(autoplayIntervalId_TSP);
            autoplayIntervalId_TSP = null;
            
            isSolving = false;
            isPaused = false;
            
            if(clearCityData){
                cities = []; 
                cityIdCounter = 0;
            }
            resetSolutionUI(); 

            if(clearCityData) {
                 logArea.innerHTML = '<p class="text-slate-400">Log messages will appear here...</p>'; 
                 addLog("System reset. Add or generate cities.");
            }


            startBtn.disabled = false;
            generateCitiesBtn.disabled = false;
            stepBtn.disabled = true;
            autoBtn.disabled = true;
            pauseBtn.disabled = true;
            resetBtn.disabled = false; 
        }
        
        function distance(cityIdx1, cityIdx2) {
            const city1 = cities[cityIdx1];
            const city2 = cities[cityIdx2];
            if (!city1 || !city2) return Infinity;
            const dx = city1.x - city2.x;
            const dy = city1.y - city2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        async function processSingleTSPStep() {
            if (tsp_step_count >= cities.length) { // All cities visited
                if (cities.length > 0 && !visited_TSP_Map.has(tour[0])) { // Ensure not already finalized
                    // Final step: return to start
                    const lastCityInTourIdx = tour[tour.length - 1];
                    const distToStart = distance(lastCityInTourIdx, tour[0]);
                    
                    highlightSegment(lastCityInTourIdx, tour[0]);
                    await sleep(animationSpeed);

                    totalDistance += distToStart;
                    visited_TSP_Map.set(tour[0], true); // Mark start as "re-visited" to complete tour
                    
                    addLog(`Returning to start City ${cities[tour[0]].id}. Dist: ${distToStart.toFixed(2)}. Tour complete.`);
                    if (cities[currentCityIndex_TSP]) cities[currentCityIndex_TSP].isCurrent = false;
                    currentCityIndex_TSP = tour[0]; // Back to start
                    redrawCanvasWithCurrentTour();
                }
                finalizeTSPSolution();
                return false; // No more steps
            }

            let nearestCityIndex = -1;
            let minDist = Infinity;

            addLog(`Current city: ${cities[currentCityIndex_TSP].id}. Finding nearest unvisited...`);

            for (let i = 0; i < cities.length; i++) {
                if (!visited_TSP_Map.has(i)) {
                    const d = distance(currentCityIndex_TSP, i);
                    if (d < minDist) {
                        minDist = d;
                        nearestCityIndex = i;
                    }
                }
            }
            
            if (nearestCityIndex !== -1) {
                highlightSegment(currentCityIndex_TSP, nearestCityIndex);
                await sleep(animationSpeed);

                totalDistance += minDist;
                if (cities[currentCityIndex_TSP]) cities[currentCityIndex_TSP].isCurrent = false; 
                
                currentCityIndex_TSP = nearestCityIndex;
                visited_TSP_Map.set(currentCityIndex_TSP, true);
                if (cities[currentCityIndex_TSP]) cities[currentCityIndex_TSP].isCurrent = true;
                tour.push(currentCityIndex_TSP);
                tsp_step_count++;
                
                addLog(`Nearest: City ${cities[currentCityIndex_TSP].id}. Dist: ${minDist.toFixed(2)}. Path: ${tour.map(idx => cities[idx].id).join('->')}`);
                redrawCanvasWithCurrentTour(); 
            } else {
                 addLog("No unvisited city found, but not all cities visited. This indicates an issue or premature end.");
                 finalizeTSPSolution(); // Should not happen if logic is correct
                 return false;
            }
            return true; // More steps possible
        }


        function startAutoplay_TSP() {
            if (autoplayIntervalId_TSP) clearInterval(autoplayIntervalId_TSP); // Clear existing
            isPaused = false;
            
            startBtn.disabled = true;
            stepBtn.disabled = true;
            autoBtn.disabled = true;
            pauseBtn.disabled = false;
            resetBtn.disabled = false;
            generateCitiesBtn.disabled = true;

            addLog("Autoplay started...");
            
            autoplayIntervalId_TSP = setInterval(async () => {
                if (isPaused) return; // Handled by pause button
                
                const moreSteps = await processSingleTSPStep();
                if (!moreSteps) {
                    pauseAutoplay_TSP(true); // Pass true to indicate it finished naturally
                }
            }, animationSpeed * 1.1);
        }

        function pauseAutoplay_TSP(finishedNaturally = false) {
            if (autoplayIntervalId_TSP) clearInterval(autoplayIntervalId_TSP);
            autoplayIntervalId_TSP = null;
            isPaused = true;

            if (!finishedNaturally) {
                addLog("Autoplay paused by user.");
            }

            if (isSolving) { // Only enable Step/Auto if solving was in progress
                startBtn.disabled = true; // Start is disabled until reset
                stepBtn.disabled = tsp_step_count >= cities.length && cities.length > 0; // Disable if tour complete
                autoBtn.disabled = tsp_step_count >= cities.length && cities.length > 0;
                pauseBtn.disabled = true;
                resetBtn.disabled = false;
                generateCitiesBtn.disabled = true; // Keep disabled if paused mid-solve
            }
        }
        
        function finalizeTSPSolution() {
            if (autoplayIntervalId_TSP) clearInterval(autoplayIntervalId_TSP);
            autoplayIntervalId_TSP = null;
            isSolving = false;
            isPaused = false; 

            pathOutput.textContent = tour.map(idx => cities[idx].id).join(' -> ') + (tour.length > 0 && cities[tour[0]] ? ` -> ${cities[tour[0]].id}` : "");
            distanceOutput.textContent = totalDistance.toFixed(2);
            if (tour.length > 0) { // Only log if a tour was actually formed
                addLog(`TSP solution found. Total distance: ${totalDistance.toFixed(2)}`);
            } else if (cities.length > 0) {
                addLog("TSP could not be completed (e.g. single city).");
            }


            startBtn.disabled = false;
            stepBtn.disabled = true;
            autoBtn.disabled = true;
            pauseBtn.disabled = true;
            resetBtn.disabled = false;
            generateCitiesBtn.disabled = false;
        }

        startBtn.addEventListener('click', () => {
            if (isSolving) return;
            if (cities.length < 2) {
                addLog("Add at least 2 cities to solve.");
                return;
            }
            isSolving = true;
            initializeTSPState();
            startAutoplay_TSP();
        });
        
        pauseBtn.addEventListener('click', () => {
            if (isSolving && !isPaused) {
                pauseAutoplay_TSP();
            }
        });

        stepBtn.addEventListener('click', async () => {
            if (!isSolving) { // If not solving, start it (paused initially for step)
                if (cities.length < 2) { addLog("Add at least 2 cities."); return; }
                isSolving = true;
                isPaused = true; // Start in paused state for stepping
                initializeTSPState();
                addLog("Initialized for stepping. Click Step to proceed.");
                startBtn.disabled = true;
                stepBtn.disabled = false;
                autoBtn.disabled = false;
                pauseBtn.disabled = true;
                resetBtn.disabled = false;
                generateCitiesBtn.disabled = true;
                return; // Wait for next step click
            }

            if (isSolving && isPaused) { // If paused and solving, perform one step
                 const moreSteps = await processSingleTSPStep();
                 if (!moreSteps) { // No more steps means it finished
                    // Finalize is called by processSingleTSPStep if it returns false
                 } else { // Still more steps, keep controls for paused stepping
                    stepBtn.disabled = false;
                    autoBtn.disabled = false;
                    pauseBtn.disabled = true;
                 }
            }
        });

        autoBtn.addEventListener('click', () => {
             if (!isSolving) { // If not solving, effectively like Start
                if (cities.length < 2) { addLog("Add at least 2 cities."); return; }
                isSolving = true;
                initializeTSPState();
                startAutoplay_TSP();
             } else if (isSolving && isPaused) { // If paused, resume autoplay
                 startAutoplay_TSP();
             }
        });


        // Initial setup
        speedValueSpan.textContent = `${animationSpeed}ms`;
        drawCities(); 
        addLog("Canvas ready. Add cities by clicking or generate randomly.");

    </script>
</body>
</html>
